因为这是假的毒瘤题，所以这题应该很简单
卢宝在玩一个扫雷游戏，这个扫雷游戏不是平常玩的那个小窗口扫雷，而是确确实实的扫雷——只有让蝈蝈把地图中的所有地雷都扫出来才能算过关。因为蝈蝈排雷技术精湛，所以就算碰到地雷蝈蝈也不会暴毙。游戏会给出一个n*m个格子的地图，每个格子可能是暗藏地雷的平地，可能是正常的平地，也可能是无法通过的障碍物。在游戏开始时扫雷师蝈蝈会随机出现在地图的某一个平地格子当中。蝈蝈会检测当前地面有没有地雷，如果有，则会将地雷排掉。因为卢宝的压迫，蝈蝈每次只能向下或者向右移动，然后继续检测地面排雷来通过游戏。因为卢宝怕蝈蝈太蠢了，不能独自排完地雷，于是临时决定给蝈蝈点技能树。于是，蝈蝈获得了放置传送门的能力，只不过，这个传送门是单向的，也就是说在一个地方放置传送门后，每次经过传送门时，都可以选择任意一个平地作为传送地点。但卢宝还是想要更多的乐趣，于是只让蝈蝈在游戏开始前放置传送门，并且故意让蝈蝈可以放置无数个传送门，因为每放置一个传送门，卢宝老板就会扣除蝈蝈的工资1k。所以蝈蝈想要使用最少的传送门并且确保无论初始出现在哪里都能够扫过所有的平地通过游戏来取悦卢宝老板，但正如卢宝担心的那样，蝈蝈太蠢了，不知道最少只需要放置几个传送门，但蝈蝈又不想被扣太多工资，所以，你能帮帮可怜的蝈蝈吗？
请告诉愚蠢的蝈蝈，最少只需要几个传送门就可以了。



说明：

1、障碍物既无法放置传送门，也无法选择作为传送地点

2、一个传送门可以传送无数次

3、蝈蝈在经过有传送门的平地时，会先排雷，再选择是否通过传送门，即不是强制传送，可以自行选择传送门传送或者不传送继续往下、右移动

4、如果地图全是障碍物，则游戏开始后且蝈蝈随机出现在地图前，蝈蝈就会获得胜利

Input
多组数据

每组数据开始输入两个整数n和m，表示地图的行数和列数（0<n,m≤1000）

接下来输入n行，每行m个字符。每个字符只存在“.”和“#”,“.”表示此格子是未检测的平地，“#”表示此格子是障碍物，无法通过。

Output
每组数据输出一行，此行包括一个整数，表示蝈蝈需要的传送门的最少数量。

SampleInput
3 3
...
.#.
...
SampleOutput
1



#include<stdio.h>
int main()
{
    int n = 0;
    int m = 0;
    char maze[1005][1005] = {0};
    while(~scanf("%d%d", &n, &m))
    {
        getchar();
        int i = 0;
        int j = 0;
        for(i = 0; i<n; i++)
        {
            scanf("%s", maze[i]);
        }
        int step = 0;
        int q = 0;
        for(i = 0; i<n; i++)//遍历二维数组
        {
            for(j = 0; j< m; j++)
            {
                if(maze[i][j] == '.')//本题关键点在于寻找有几个死角
                {
                    step++;//判断有几个空地，来做特判
                    if((maze[i+1][j] == '#' || i == n-1) && (maze[i][j+1] == '#' || j == m-1))
                    {
                        q++;//找到死角，传送门++
                    }
                }
            }
        }
        if(step == 1)//特判，如果只有一个空地，传送门为0
        {
            q = 0;
        }
        printf("%d\n", q);
    }
    return 0;
}

