蝈蝈有n堆纸牌，每堆都有若干张纸牌，且全部堆的纸牌总数是n的倍数。现在每次可以从任意一堆中拿出若干纸牌移动到左右任意相邻的一堆中。第一堆因为左边没有堆，只能放至第二堆；第n堆因为右边没有堆，只能放到第n-1堆。如果要让所有堆中纸牌数量相同，则最少需要移动多少次？



2021.10.6：数据加强

Input
第一行一个整数n，表示堆的数量（1≤n≤50）

第二行n个整数ai，表示每个堆原本的纸牌数量（1≤ai≤1000）

Output
输出最少的移动次数

SampleInput
4
9 8 17 6
SampleOutput
3

#include<stdio.h>
//贪心，把大问题化为小问题   只看一小部分
//先把左边的牌堆干净 
int main()
{
   int n = 0;
   int i = 0;
   int sum = 0;
   int step = 0;
   int a[1005] = {0};
   scanf("%d", &n);
   for(i = 0; i<n; i++)
   {
       scanf("%d", &a[i]);
       sum+=a[i];//计算总张数
   }
   sum/=n;//表示每一堆的数量
   for(i = 0; i<n; i++)//遍历数组
   {
       if(a[i]!= sum)//如果不相等，次数+1
       {
           step++;
           a[i+1]+=(a[i]-sum);//从左到右，多了的牌给下一位，少了的牌当做从前面赊账
       }
   }
   printf("%d", step);
    return 0;
}
