设计要点
可以通过反复求两个正整数的最大公因数和最小公倍数的方法来实现。
规定（a,b)为a，b的最大公因数，{a，b}为最小公倍数。
对于3个或3个以上的正整数，最大公约数与最小公倍数有以下性质：

(al，a2.a3)=((al，a2)，a3)。
(al，a2.a3，a4)=((al，a2，a3)，a4)，...
{al，a2，a3}=({al，a2}，a3}。
{al，a2，a3，a4}={{al，a2，a3}，a4}，...
应用这一性质，要求n个整数的最大公约数，先求出前n-1个整数的最大公约数b，再求第n个数与b的最大公约数：
要求n个整数的最小公倍数，先求出前n-1个整数的最小公倍数b，再求第n个数与b的最小公倍数。求n个数的最大公约数。
为便于输出，设置m数组：
1)输入的n个正整数存储在m数组m[0]，m[1]，...，m[n-1]中。
2)，开始时b=m[0]，即输入的第一个数赋值给变量b。
3)进入k循环，每次把输入的数m[1]~m[n-1]赋值给a求得a、b的最大公约数c。如果c=l，退出循环，即m数组的最大公约数为1：否则赋值给b，即b=c，为下一轮运算做准备。求n个数的最小公倍数与上述类似。
*代码*
#include<stdio.h>
int main()
{
    long long int n = 0;
    while(scanf("%d", &n) != EOF)
    {
        if(2<=n && n<= 1000)
        {
            long long int m,a,b,c,arr[1005];
        for(int i = 0; i< n; i++)
        {
            scanf("%lld", &arr[i]);
        }
        b = arr[0];
        for(int i = 1;i< n; i++)
        {
            a = arr[i];
            if(a < b)
            {
                c = a;
                a = b;
                b = c;
            }
            while( b!= 0 && a % b )
                {
                    m = a % b;
                    a = b;
                    b = m;
                }
        }
        printf("%lld\n", b);
        }
    }
    return 0;
}
