自从上了高数课后，徐老师的寝室就多了一个传统，就是不论是谁,除了徐老师寝室的哲学带师ZY先生，他的外号都可以是虚拢，而虚拢的拼音是Xulong（X是大写，我不管,我就要这样,傲娇脸）

现在要竞选出那个虚拢的王，每个人写出一串字符，用这串字符来判断每个人的虚拢值每个人开始的虚拢数值都为0，如果字符串中出现了X，u，l，o，n，g，虚拢值+1，但是如果出现了Xulong的前缀（前缀包括X,Xu，Xul,Xulo,Xulon,Xulong），那么他的虚拢值飞速增长，如 X额外增加10， Xu  额外增加20，Xul额外增加30，额外增加的规律是他连续的长度*10，但是如果出现了ZY这两个字母则无论怎么样他的虚拢值都为0，来吧，找出其中的虚拢王(虚拢值最大)的序号(从1到n)

说明:
1、前缀不会叠加，比如“Xu”，只会算“Xu”的额外虚拢值20，不会再算“X”的额外虚拢值10
即“Xu”字符串的虚拢值计算为：“X”和“u”两个单个字母的虚拢值1，加上“Xu”的额外虚拢值20，所以“Xu”的虚拢值为1+1+20=22
2、只要字符串中出现“Z”和“Y”两个字母则虚拢值为0，即两个字母不用连续，也不用管前后顺序

Input
第一行输入参加虚拢王竞争的虚拢的个数n（1≤n≤1000）

从2到n+1行输入每个虚拢写下的字符串（1≤每行字符串的长度≤1000）

字符串只包含大小写字母

Output
输出一行，表示虚拢值最大的虚拢王的序号
（如果同时存在多个虚拢值最大的虚拢王，则按照序号从小到大每个序号输出一行）

SampleInput
3
X
o
Xa

4
ZAY
Xulong
xulong
XulongKing
SampleOutput
1 
3

4


//本题超级BUG点  在于 用scanf 输入 可以   但是用gets是不行的   原因未知。。。问就是回车出问题，但是我也不知道具体哪里出问题
//本题思路关键在于统计数组中的虚龙值，然后依次存入另一个存放虚龙值的数组，其数组的下标就是其序号，记录下最大值，然后遍历数组查找出最大值的
下标即可，其次根据要求如果有多个最大值，将其全部输出，那么遍历数组的时候，输出值为最大值的下标。
#include<stdio.h>
#include<math.h>
#include<string.h>
char a[1005];//存放字符串
int b[1005];//存放虚龙值
int main()
{
    int n = 0;
    scanf("%d", &n);
    getchar();
    int p = n;//存储n的值
    int k = 0;
    int i = 0;
    int max = 0;
    while(n--)
    {
        int num = 0;
        memset(a,0,sizeof(a));
        scanf("%s", a);
        getchar();
        int Z1 = 0;
        int Y1 = 0;
        int len = strlen(a);
        for(i =0; i<len; i++)//遍历a数组
        {
            if(a[i] == 'Z' )//如果出现Z，并标记Z已统计过
            {
                Z1 = 1;
            }
            if(a[i] == 'Y' )//如果出现Y
            {
                Y1 = 1;
            }
            if(Z1 ==1 && Y1 == 1)//表示出现Z和Y为0 不再遍历,虚龙值设为0
            {
                num = 0;
                break;
            }
            if(a[i] == 'X'|| a[i] == 'u'||a[i] == 'l'||a[i] == 'o'||a[i] == 'n'||a[i] == 'g')
            {
                num++;
            }
            if(a[i] == 'X')
            {
                num+=10;
                if(a[i+1] == 'u')
                {
                    num+=10;
                    if(a[i+2] == 'l')
                    {
                        num+=10;
                        if(a[i+3] == 'o')
                        {
                            num+=10;
                            if(a[i+4] == 'n')
                            {
                                num+=10;
                                if(a[i+5] == 'g')
                                {
                                    num+=10;
                                }
                            }
                        }
                    }
                }
            }
        }
        b[k] = num;//记录虚龙值
        if(max < b[k])//记录最大值
        {
            max = b[k];
        }
        k++;//放下一个虚龙值
    }
    for(i = 0; i< p; i++)
    {
        if(b[i] == max)//寻找最大值的序号
        {
            printf("%d\n", i+1);
        }
    }

    return 0;
}
